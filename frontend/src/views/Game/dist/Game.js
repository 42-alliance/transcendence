/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Game.ts":
/*!*********************!*\
  !*** ./src/Game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nlet username = 'Test'; // Placeholder for username\nconst canvas = document.getElementById(\"game-canvas\");\nif (canvas == null) {\n    console.error(\"Impossible de récupérer le canvas\");\n}\nconst loadingCanvas = document.getElementById(\"loading-canvas\");\nconst gameCanvas = document.getElementById(\"game-canvas\");\nconst ctx = loadingCanvas ? loadingCanvas.getContext(\"2d\") : null;\nlet stat = \"loading\";\nlet video = null; // Declare video outside of the drawing function\n// Global variables for game objects\nlet ball;\nlet paddle1;\nlet paddle2;\nlet gameSocket; // Single WebSocket instance\n// Add a score display element\nlet scoreElement;\nfunction setupGameScoreDisplay() {\n    // Create a div for score display if it doesn't exist\n    if (!document.getElementById('game-score')) {\n        scoreElement = document.createElement('div');\n        scoreElement.id = 'game-score';\n        scoreElement.style.position = 'absolute';\n        scoreElement.style.top = '10px';\n        scoreElement.style.left = '50%';\n        scoreElement.style.transform = 'translateX(-50%)';\n        scoreElement.style.color = 'white';\n        scoreElement.style.fontSize = '24px';\n        scoreElement.style.fontWeight = 'bold';\n        scoreElement.style.textShadow = '2px 2px 4px #000000';\n        scoreElement.innerText = '0 - 0';\n        document.body.appendChild(scoreElement);\n    }\n    else {\n        scoreElement = document.getElementById('game-score');\n    }\n}\nfunction drawingLoadingPage() {\n    if (!ctx)\n        return;\n    if (loadingCanvas == null)\n        return; // Use loadingCanvas instead of canvas\n    // Create video element only once\n    if (!video) {\n        video = document.createElement(\"video\");\n        video.src = \"./asset/waiting.mp4\"; // Make sure the path is correct\n        video.loop = true;\n        video.autoplay = true;\n        video.muted = true;\n        video.style.filter = \"blur(20px)\";\n        video.play(); // Start playing\n    }\n    // Set canvas size\n    loadingCanvas.width = 1200; // Use loadingCanvas instead of canvas\n    loadingCanvas.height = 700;\n    let textX = -300; // Start position of text\n    let textSpeed = 2; // Speed of text movement\n    let text = \"WAITING FOR OPPONENT\";\n    let period = \".\";\n    let i = 0;\n    setInterval(() => {\n        if (i < 3) {\n            text += period;\n            i++;\n        }\n        else {\n            text = \"WAITING FOR OPPONENT\";\n            i = 0;\n        }\n    }, 500);\n    function animate() {\n        if (loadingCanvas == null)\n            return; // Use loadingCanvas instead of canvas\n        if (ctx == null)\n            return;\n        if (video == null)\n            return;\n        ctx.clearRect(0, 0, loadingCanvas.width, loadingCanvas.height); // Clear canvas\n        ctx.drawImage(video, 0, 0, loadingCanvas.width, loadingCanvas.height); // Draw the video on canvas\n        ctx.font = \"bold 72px Arial, Helvetica, sans-serif\";\n        const gradient = ctx.createLinearGradient(0, loadingCanvas.height - 150, 0, loadingCanvas.height - 50);\n        gradient.addColorStop(0, '#E93240');\n        gradient.addColorStop(1, '#EE4B2B');\n        ctx.shadowColor = \"rgba(0, 0, 0, 0.5)\";\n        ctx.shadowBlur = 10;\n        ctx.shadowOffsetX = 5;\n        ctx.shadowOffsetY = 5;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillStyle = gradient;\n        ctx.fillText(text, textX, loadingCanvas.height - 100);\n        textX = loadingCanvas.width / 2; // Update text position\n        requestAnimationFrame(animate); // Loop animation\n    }\n    // Start animation when the video is ready\n    video.onloadeddata = () => {\n        if (stat === \"loading\")\n            animate();\n    };\n}\nfunction render() {\n    connectWebSocket(); // Set up WebSocket with proper message handlers\n    drawingLoadingPage();\n    // Start animation loop separately\n    requestAnimationFrame(animate);\n}\nfunction renderGame() {\n    if (loadingCanvas)\n        loadingCanvas.style.display = \"none\";\n    if (gameCanvas)\n        gameCanvas.style.display = \"block\";\n    // Check if WebGL is supported\n    if (!window.BABYLON || !window.BABYLON.Engine.isSupported()) {\n        console.error(\"WebGL not supported\");\n        alert(\"WebGL is not supported by your browser or environment.\");\n        return;\n    }\n    // Create the engine and scene when the game starts\n    if (gameCanvas == null)\n        return;\n    const engine = new window.BABYLON.Engine(gameCanvas, true);\n    const scene = new window.BABYLON.Scene(engine);\n    // Setup camera\n    const camera = new window.BABYLON.ArcRotateCamera(\"camera\", Math.PI / 2, Math.PI / 3, 10, new window.BABYLON.Vector3(0, 0, 0), scene);\n    // Disable keyboard controls for the camera, but keep mouse controls\n    camera.attachControl(gameCanvas, true, false, false); // The third parameter disables keyboard controls\n    // Alternative approach if the above doesn't work with your Babylon.js version:\n    camera.inputs.attached.keyboard.detachControl();\n    // Add lighting\n    const light = new window.BABYLON.HemisphericLight(\"light\", new window.BABYLON.Vector3(0, 1, 0), scene);\n    // Create the game table (ping pong table)\n    const table = window.BABYLON.MeshBuilder.CreateBox(\"table\", {\n        width: 8,\n        height: 0.2,\n        depth: 4\n    }, scene);\n    table.position.y = -0.1;\n    const tableMaterial = new window.BABYLON.StandardMaterial(\"tableMaterial\", scene);\n    tableMaterial.diffuseColor = new window.BABYLON.Color3(0, 0.3, 0);\n    table.material = tableMaterial;\n    // Create the net\n    const net = window.BABYLON.MeshBuilder.CreateBox(\"net\", {\n        width: 0.05,\n        height: 0.3,\n        depth: 4\n    }, scene);\n    net.position.y = 0.15;\n    const netMaterial = new window.BABYLON.StandardMaterial(\"netMaterial\", scene);\n    netMaterial.diffuseColor = new window.BABYLON.Color3(1, 1, 1);\n    net.material = netMaterial;\n    // Create the ball\n    ball = window.BABYLON.MeshBuilder.CreateSphere(\"ball\", {\n        diameter: 0.2\n    }, scene);\n    ball.position.y = 0.5;\n    const ballMaterial = new window.BABYLON.StandardMaterial(\"ballMaterial\", scene);\n    ballMaterial.diffuseColor = new window.BABYLON.Color3(1, 0.8, 0.2);\n    ball.material = ballMaterial;\n    // Create paddles\n    paddle1 = window.BABYLON.MeshBuilder.CreateBox(\"paddle1\", {\n        width: 0.2,\n        height: 0.5,\n        depth: 1\n    }, scene);\n    paddle1.position.x = -3.5;\n    paddle1.position.y = 0.25;\n    paddle2 = window.BABYLON.MeshBuilder.CreateBox(\"paddle2\", {\n        width: 0.2,\n        height: 0.5,\n        depth: 1\n    }, scene);\n    paddle2.position.x = 3.5;\n    paddle2.position.y = 0.25;\n    const paddleMaterial = new window.BABYLON.StandardMaterial(\"paddleMaterial\", scene);\n    paddleMaterial.diffuseColor = new window.BABYLON.Color3(0.8, 0.2, 0.2);\n    paddle1.material = paddleMaterial;\n    paddle2.material = paddleMaterial;\n    // Run the render loop\n    engine.runRenderLoop(() => {\n        scene.render();\n    });\n    // Handle window resize\n    window.addEventListener('resize', () => {\n        engine.resize();\n    });\n    // Setup game communication once objects are created\n    // At the end, make sure to remove the unnecessary animate() call\n    // since we'll start it separately\n}\nconst socket = new WebSocket(\"ws://localhost:8790\");\nfunction connectWebSocket() {\n    socket.onopen = () => {\n        console.log(\"WebSocket connection established\");\n        socket.send(JSON.stringify({ type: 'online', username: username }));\n    };\n    socket.onerror = (error) => {\n        console.error('WebSocket error:', error);\n    };\n    socket.onclose = () => {\n        console.log(\"WebSocket connection closed\");\n    };\n    // Set up the message handler to process game updates\n    socket.onmessage = (event) => {\n        try {\n            const message = JSON.parse(event.data);\n            switch (message.type) {\n                case 'match_found':\n                    stat = \"game\";\n                    console.log('Match found, starting game');\n                    // Clean up loading screen\n                    if (video) {\n                        video.pause();\n                        video.currentTime = 0;\n                    }\n                    if (ctx && loadingCanvas) {\n                        ctx.clearRect(0, 0, loadingCanvas.width, loadingCanvas.height);\n                        renderGame();\n                        setupGameScoreDisplay();\n                        setupKeyboardControls(); // Add this line to set up keyboard controls\n                    }\n                    break;\n                case 'update':\n                    // Handle game object updates using the correct data structure\n                    if (!message.data) {\n                        console.error(\"Missing data in update message:\", message);\n                        return;\n                    }\n                    const gameState = message.data;\n                    // Map 2D coordinates to 3D world space\n                    if (ball && gameState.ball) {\n                        // Map ball position\n                        // Assuming backend coordinates are: x (0 to width), y (0 to height)\n                        // Convert to 3D where: x (-4 to 4), z (-2 to 2), y fixed above table\n                        const normalizedX = (gameState.ball.x / 600) - 0.5; // Assuming width=600, normalize to -0.5 to 0.5\n                        const normalizedZ = (gameState.ball.y / 400) - 0.5; // Assuming height=400, normalize to -0.5 to 0.5\n                        // Scale to table dimensions\n                        ball.position.x = normalizedX * 8; // Table is 8 units wide\n                        ball.position.z = normalizedZ * 4; // Table is 4 units deep\n                        ball.position.y = 0.5; // Fixed height above table\n                    }\n                    // Update paddle positions\n                    if (paddle1 && gameState.paddle1) {\n                        // Convert 2D y-position to 3D z-position\n                        const normalizedZ = (gameState.paddle1.y / 400) - 0.5; // Normalize to -0.5 to 0.5\n                        // Fixed x position at left side of table, variable z position\n                        paddle1.position.x = -3.5; // Fixed at left edge\n                        paddle1.position.z = normalizedZ * 4; // Map to table depth\n                        paddle1.position.y = 0.25; // Fixed height\n                    }\n                    if (paddle2 && gameState.paddle2) {\n                        // Convert 2D y-position to 3D z-position\n                        const normalizedZ = (gameState.paddle2.y / 400) - 0.5; // Normalize to -0.5 to 0.5\n                        // Fixed x position at right side of table, variable z position\n                        paddle2.position.x = 3.5; // Fixed at right edge\n                        paddle2.position.z = normalizedZ * 4; // Map to table depth\n                        paddle2.position.y = 0.25; // Fixed height\n                    }\n                    // Update score display\n                    if (gameState.score && scoreElement) {\n                        scoreElement.innerText = `${gameState.score.p1} - ${gameState.score.p2}`;\n                    }\n                    break;\n                default:\n                    console.log(\"Unhandled message type:\", message.type);\n            }\n        }\n        catch (error) {\n            console.error(\"Error processing WebSocket message:\", error);\n        }\n    };\n}\n// Add this function to handle keyboard controls\nfunction setupKeyboardControls() {\n    // Remove any existing event listeners first to prevent duplicates\n    document.removeEventListener('keydown', handleKeyDown);\n    // Add the event listener for keydown events with useCapture=true to intercept before camera\n    document.addEventListener('keydown', handleKeyDown, true);\n    // For debugging purposes, let's add a visual indicator that a key was pressed\n    console.log(\"Keyboard controls set up\");\n}\n// Function to handle key presses and send commands to the server\nfunction handleKeyDown(event) {\n    // Only react to arrow keys\n    if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n        // Prevent default behavior and stop propagation\n        event.preventDefault();\n        event.stopPropagation(); // This prevents the event from reaching the camera\n        console.log(`Key pressed: ${event.key}`); // Debug output\n        // Send the command to the WebSocket server\n        if (socket && socket.readyState === WebSocket.OPEN) {\n            if (socket.readyState === WebSocket.OPEN) {\n                socket.send(JSON.stringify({\n                    type: 'key_command',\n                    username: username,\n                    key: event.key\n                }));\n            }\n            else {\n                console.error('WebSocket is not open. ReadyState:', socket.readyState);\n            }\n            console.log('Key command sent to server'); // Debug output\n        }\n    }\n}\nfunction animate() {\n    // No need to reassign socket.onmessage here - it's already set in connectWebSocket\n    // Just set up a frame loop to keep the game rendering\n    requestAnimationFrame(animate);\n}\n//animate loop\nrender();\n\n\n\n//# sourceURL=webpack://game/./src/Game.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/Game.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;